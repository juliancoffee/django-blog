#
# This whole file was, again, almost entirely generated by coderabbitai
#
# Is it wise? idk, we'll see.
# It works though.
import json
import logging
from datetime import UTC, datetime
from itertools import chain

from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.db.utils import IntegrityError
from django.forms import Form
from django.test import TestCase
from django.test.client import RequestFactory
from django.urls import reverse

from blog.models import Comment, Post

from .dataexport import format_date, get_all_data, get_post_data
from .dataimport import FormError, data_from, load_all_data_in

# It still doesn't work half of the time
logging.disable()

SAMPLE_DATA = {
    "posts": [
        {
            "post_text": "Imported Post 1",
            "pub_date": "2023-02-01T10:00:00+00:00",
            "comments": [
                {
                    "comment_text": "Imported Comment 1",
                    "pub_date": "2023-02-01T10:30:00+00:00",
                    "username": None,
                    "ip": "192.168.1.1",
                },
                {
                    "comment_text": "Imported Comment 2",
                    "pub_date": "2023-02-01T11:00:00+00:00",
                    "username": None,
                    "ip": "192.168.1.2",
                },
            ],
        },
        {
            "post_text": "Imported Post 2",
            "pub_date": "2023-02-02T10:00:00+00:00",
            "comments": [
                {
                    "comment_text": "Imported Comment 3",
                    "pub_date": "2023-02-02T10:30:00+00:00",
                    "username": None,
                    "ip": "192.168.1.3",
                }
            ],
        },
    ],
    "users": [],
}


def create_test_file(data=None) -> SimpleUploadedFile:
    """Helper method to create a test JSON file for import"""
    if data is None:
        data = SAMPLE_DATA

    json_data = json.dumps(data)
    return SimpleUploadedFile(
        "test_import.json",
        json_data.encode("utf-8"),
        content_type="application/json",
    )


class DataExportTests(TestCase):
    def setUp(self):
        # Create a staff user
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

        # Create test posts with comments
        self.post1 = Post.objects.create(
            post_text="Test Post 1",
            pub_date=datetime(2023, 1, 1, tzinfo=UTC),
        )
        self.post2 = Post.objects.create(
            post_text="Test Post 2",
            pub_date=datetime(2023, 1, 2, tzinfo=UTC),
        )

        # Add comments to posts
        self.comment1 = self.post1.comment_set.create(
            comment_text="Test Comment 1",
            pub_date=datetime(2023, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )
        self.comment2 = self.post1.comment_set.create(
            comment_text="Test Comment 2",
            pub_date=datetime(2023, 1, 1, 2, tzinfo=UTC),
            commenter_ip="127.0.0.2",
        )
        self.comment3 = self.post2.comment_set.create(
            comment_text="Test Comment 3",
            pub_date=datetime(2023, 1, 2, 1, tzinfo=UTC),
            commenter_ip="127.0.0.3",
        )

    def test_format_date(self):
        """Test that dates are formatted correctly in ISO format"""
        test_date = datetime(2023, 1, 1, tzinfo=UTC)
        formatted = format_date(test_date)
        self.assertEqual(formatted, "2023-01-01T00:00:00+00:00")

    def test_get_post_data_with_comments(self):
        """Test that get_post_data returns correct data structure with comments"""
        post_data = get_post_data()

        # Should be ordered by date
        self.assertEqual(len(post_data), 2)
        self.assertEqual(post_data[0]["post_text"], "Test Post 1")
        self.assertEqual(post_data[1]["post_text"], "Test Post 2")

        # Check comments
        self.assertEqual(len(post_data[0]["comments"]), 2)
        self.assertEqual(len(post_data[1]["comments"]), 1)

        # Check structure of first post's first comment
        first_comment = post_data[0]["comments"][0]
        self.assertEqual(first_comment["comment_text"], "Test Comment 1")
        self.assertEqual(first_comment["ip"], "127.0.0.1")
        self.assertIsNone(
            first_comment["username"]
        )  # username is None since not implemented yet

    def test_get_all_data(self):
        """Test that get_all_data returns correct overall structure"""
        all_data = get_all_data()

        self.assertIn("posts", all_data)
        self.assertIn("users", all_data)
        self.assertEqual(len(all_data["posts"]), 2)
        self.assertEqual(
            len(all_data["users"]), 0
        )  # User data not implemented yet

    def test_export_endpoint(self):
        """Test the export endpoint returns a json file with correct content"""
        response = self.client.get(
            reverse("blog:management:download_exported_file"),
            {"download": True},
        )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response["Content-Type"], "application/json")

        # Parse the JSON response
        assert hasattr(response, "streaming_content")
        json_data = json.loads(b"".join(response.streaming_content))

        # Verify structure
        self.assertIn("posts", json_data)
        self.assertIn("users", json_data)
        self.assertEqual(len(json_data["posts"]), 2)

    def test_export_with_no_posts(self):
        """Test export with empty database"""
        # Clear all posts
        Post.objects.all().delete()

        post_data = get_post_data()
        self.assertEqual(len(post_data), 0)

        all_data = get_all_data()
        self.assertEqual(len(all_data["posts"]), 0)

        # Test export endpoint with empty database
        response = self.client.get(
            reverse("blog:management:download_exported_file"),
            {"download": True},
        )

        assert hasattr(response, "streaming_content")
        json_data = json.loads(b"".join(response.streaming_content))

        # Verify structure
        self.assertEqual(len(json_data["posts"]), 0)


class DataImportTests(TestCase):
    def setUp(self):
        # Create a staff user for testing
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

    def test_import_with_empty_database(self):
        """Test importing posts into an empty database"""
        # Verify database is empty
        self.assertEqual(Post.objects.count(), 0)
        self.assertEqual(Comment.objects.count(), 0)

        # Create and upload import file
        import_file = create_test_file()
        response = self.client.post(
            reverse("blog:management:handle_import"), {"data_file": import_file}
        )

        # Verify successful import
        self.assertEqual(response.status_code, 200)

        # Verify database now has the imported data
        self.assertEqual(Post.objects.count(), 2)
        self.assertEqual(Comment.objects.count(), 3)

        # Check specific post content
        posts = Post.objects.all().order_by("pub_date")
        self.assertEqual(posts[0].post_text, "Imported Post 1")
        self.assertEqual(posts[1].post_text, "Imported Post 2")

        # Check comment counts per post
        self.assertEqual(posts[0].comment_set.count(), 2)
        self.assertEqual(posts[1].comment_set.count(), 1)

    def test_import_preserves_existing_posts(self):
        """Test importing doesn't duplicate existing posts"""
        # Create a post with the same text as in sample data
        existing_post = Post.objects.create(
            post_text="Imported Post 1",
            pub_date=datetime(2022, 1, 1, tzinfo=UTC),  # Different date
        )
        existing_post.comment_set.create(
            comment_text="Existing Comment",
            pub_date=datetime(2022, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )

        # Initial counts
        self.assertEqual(Post.objects.count(), 1)
        self.assertEqual(Comment.objects.count(), 1)

        # Create and upload import file
        import_file = create_test_file()
        response = self.client.post(
            reverse("blog:management:handle_import"), {"data_file": import_file}
        )

        # Verify successful import
        self.assertEqual(response.status_code, 200)

        # Verify database now has the correct data
        self.assertEqual(Post.objects.count(), 2)  # Original + 1 new
        self.assertEqual(
            Comment.objects.count(), 2
        )  # Original + 1 new from 2nd post

        # Check that existing post comments weren't modified
        existing_post.refresh_from_db()
        self.assertEqual(existing_post.comment_set.count(), 1)
        existing_comment = existing_post.comment_set.first()
        assert existing_comment is not None
        self.assertEqual(existing_comment.comment_text, "Existing Comment")

    def test_import_preview_endpoint(self):
        """Test the import preview endpoint"""
        # Prepare import request with file
        import_file = create_test_file()

        # Post to import preview endpoint
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": import_file},
        )

        # Verify response
        self.assertEqual(response.status_code, 200)

        # Database should remain unchanged after preview
        self.assertEqual(Post.objects.count(), 0)
        self.assertEqual(Comment.objects.count(), 0)

    def test_import_preserves_data_integrity(self):
        """Test that import maintains referential integrity"""
        # Create and upload import file
        import_file = create_test_file()
        self.client.post(
            reverse("blog:management:handle_import"), {"data_file": import_file}
        )

        # Verify all comments have valid post references
        for comment in Comment.objects.all():
            self.assertIsNotNone(comment.post)
            self.assertTrue(Post.objects.filter(id=comment.post.id).exists())

        # Verify data matches expected values
        post = Post.objects.get(post_text="Imported Post 1")
        comments = post.comment_set.all().order_by("pub_date")
        self.assertEqual(comments[0].comment_text, "Imported Comment 1")
        self.assertEqual(comments[1].comment_text, "Imported Comment 2")


class DataImportUnitTest(TestCase):
    def setUp(self):
        # Create a staff user for testing
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

    def test_import_invalid_form_format(self):
        """Test that parsed_import_data rejects malformed requests"""
        # Create a non-JSON file
        invalid_file = SimpleUploadedFile(
            "test.txt", b"This is not JSON", content_type="text/plain"
        )

        rf = RequestFactory()
        request = rf.post(
            "/whatever/",
            {"data_file": invalid_file},
        )

        with self.assertRaises(FormError):
            data_from(request).ok_or_raise()

    def test_import_transaction_atomicity(self):
        """Test that imports are atomic - either all succeeds or nothing changes"""
        # Create a post that will already exist in the database
        existing_post = Post.objects.create(
            post_text="Existing Post", pub_date=datetime(2023, 1, 1, tzinfo=UTC)
        )
        existing_post.comment_set.create(
            comment_text="Existing Comment",
            pub_date=datetime(2023, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )

        # Initial database state
        initial_post_count = Post.objects.count()
        initial_comment_count = Comment.objects.count()

        # Create the test file with malformed data
        import_file = create_test_file()

        # Try to import the malformed data
        rf = RequestFactory()
        request = rf.post(
            "/whatever/",
            {"data_file": import_file},
        )

        data = data_from(request).ok_or_raise()

        # Intentionally fuck up second post
        data.posts[1].pub_date = None  # type: ignore[assignment]

        # Catch an integrity error
        with self.assertRaises(IntegrityError):
            load_all_data_in(data)

        # Verify database state is unchanged
        self.assertEqual(
            Post.objects.count(),
            initial_post_count,
            "Post count should be unchanged after failed import",
        )
        self.assertEqual(
            Comment.objects.count(),
            initial_comment_count,
            "Comment count should be unchanged after failed import",
        )

        # Verify that none of the valid posts were imported either
        self.assertFalse(
            Post.objects.filter(post_text="Imported Post 1").exists(),
            "Valid Post 1 should not exist after a failed transaction",
        )
        self.assertFalse(
            Post.objects.filter(post_text="Imported Post 2").exists(),
            "Valid Post 2 should not exist after a failed transaction",
        )


class FormTestCase(TestCase):
    # I know that assertFormError exists, but it requires a fieldname, and that's
    # a weird limitation imo, so here's my version instead.
    def assertFormContainsErrorCode(self, response, error_code: str):
        """Check that form errors contain the error with error_code"""
        form: Form = response.context["form"]
        errors = form.errors.get_json_data()

        # flatmap and find the code for each message for each field
        # NOTE: eagerly evaluate the iterable for better error messages, but
        # it'd work without it as well
        error_codes = list(
            map(lambda e: e["code"], chain.from_iterable(errors.values()))
        )

        self.assertIn(error_code, error_codes)


class ImportErrorHandlingTests(FormTestCase):
    def setUp(self):
        # Create a staff user for testing
        from django.contrib.auth.models import User

        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

        # Define various test files
        self.empty_file = SimpleUploadedFile(
            "empty.json", b"", content_type="application/json"
        )

        self.non_json_file = SimpleUploadedFile(
            "test.txt", b"This is not JSON", content_type="text/plain"
        )

        self.invalid_json = SimpleUploadedFile(
            "invalid.json",
            b"{not valid json syntax}",
            content_type="application/json",
        )

        self.malformed_json = SimpleUploadedFile(
            "malformed.json",
            b'{"this_is": "valid json", "but": "wrong structure"}',
            content_type="application/json",
        )

        # Create an oversized file (> 5MB)
        oversized_content = b"x" * (10 * 1024 * 1024 + 1)  # 10MB + 1 byte
        self.oversized_file = SimpleUploadedFile(
            "oversized.json", oversized_content, content_type="application/json"
        )

    # Tests for handle_import_preview

    def test_preview_missing_file(self):
        """Test that import preview returns form error when no file is submitted"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {},  # Empty form data
        )

        self.assertEqual(response.status_code, 200)
        self.assertFormContainsErrorCode(response, "required")
        self.assertContains(response, '<div id="import-form-error"')

    def test_preview_non_json_file(self):
        """Test that import preview validates file extension"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": self.non_json_file},
        )

        self.assertEqual(response.status_code, 200)
        self.assertFormContainsErrorCode(response, "invalid_extension")
        self.assertContains(response, '<div id="import-form-error"')

    def test_preview_oversized_file(self):
        """Test that import preview validates file size"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": self.oversized_file},
        )

        self.assertEqual(response.status_code, 200)
        self.assertFormContainsErrorCode(response, "file_size_exceeded")
        self.assertContains(response, '<div id="import-form-error"')

    def test_preview_invalid_json_syntax(self):
        """Test that import preview handles invalid JSON syntax"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": self.invalid_json},
        )

        self.assertEqual(response.status_code, 200)
        self.assertFormContainsErrorCode(response, "format")
        self.assertContains(response, "Unable to parse the file")
        self.assertContains(response, '<div id="import-form-error"')

    def test_preview_malformed_data_structure(self):
        """Test that import preview validates data structure"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": self.malformed_json},
        )

        self.assertEqual(response.status_code, 200)
        self.assertFormContainsErrorCode(response, "format")
        self.assertContains(response, "Unable to parse the file")
        self.assertContains(response, '<div id="import-form-error"')

    def test_preview_no_import_button_on_error(self):
        """Test that the import button isn't shown when preview has errors"""
        response = self.client.post(
            reverse("blog:management:handle_import_preview"),
            {"data_file": self.invalid_json},
        )

        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, 'id="import-submit-button"')

    # Tests for handle_import

    def test_import_missing_file(self):
        """Test that import returns error when no file is submitted"""
        response = self.client.post(
            reverse("blog:management:handle_import"),
            {},  # Empty form data
        )

        self.assertEqual(response.status_code, 200)
        # The implementation just returns HttpResponse with the FormError
        self.assertContains(response, "This field is required")

    def test_import_non_json_file(self):
        """Test that import validates file extension"""
        response = self.client.post(
            reverse("blog:management:handle_import"),
            {"data_file": self.non_json_file},
        )

        self.assertEqual(response.status_code, 200)
        # The implementation returns HttpResponse with the FormError
        self.assertContains(response, "File extension")

    def test_import_oversized_file(self):
        """Test that import validates file size"""
        response = self.client.post(
            reverse("blog:management:handle_import"),
            {"data_file": self.oversized_file},
        )

        self.assertEqual(response.status_code, 200)
        # The implementation returns HttpResponse with the FormError
        self.assertContains(response, "File size")

    def test_import_invalid_json_syntax(self):
        """Test that import handles invalid JSON syntax"""
        response = self.client.post(
            reverse("blog:management:handle_import"),
            {"data_file": self.invalid_json},
        )

        self.assertEqual(response.status_code, 200)
        # The implementation returns a generic error message for DataError
        self.assertContains(response, "sommry, something went wrong")

    def test_import_malformed_data_structure(self):
        """Test that import validates data structure"""
        response = self.client.post(
            reverse("blog:management:handle_import"),
            {"data_file": self.malformed_json},
        )

        self.assertEqual(response.status_code, 200)
        # The implementation returns a generic error message for DataError
        self.assertContains(response, "sommry, something went wrong")
