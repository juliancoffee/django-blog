#
# This whole file was, again, almost entirely generated by coderabbitai
#
# Is it wise? idk, we'll see.
# It works though.
import json
from datetime import UTC, datetime

from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.test import TestCase
from django.urls import reverse

from blog.models import Comment, Post

from .dataexport import CommentData as ExportDataComment
from .dataexport import PostData as ExportPostData
from .dataexport import format_date, get_all_data, get_post_data
from .dataimport import convert_comment, convert_post


class DataExportTests(TestCase):
    def setUp(self):
        # Create a staff user
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

        # Create test posts with comments
        self.post1 = Post.objects.create(
            post_text="Test Post 1",
            pub_date=datetime(2023, 1, 1, tzinfo=UTC),
        )
        self.post2 = Post.objects.create(
            post_text="Test Post 2",
            pub_date=datetime(2023, 1, 2, tzinfo=UTC),
        )

        # Add comments to posts
        self.comment1 = self.post1.comment_set.create(
            comment_text="Test Comment 1",
            pub_date=datetime(2023, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )
        self.comment2 = self.post1.comment_set.create(
            comment_text="Test Comment 2",
            pub_date=datetime(2023, 1, 1, 2, tzinfo=UTC),
            commenter_ip="127.0.0.2",
        )
        self.comment3 = self.post2.comment_set.create(
            comment_text="Test Comment 3",
            pub_date=datetime(2023, 1, 2, 1, tzinfo=UTC),
            commenter_ip="127.0.0.3",
        )

    def test_format_date(self):
        """Test that dates are formatted correctly in ISO format"""
        test_date = datetime(2023, 1, 1, tzinfo=UTC)
        formatted = format_date(test_date)
        self.assertEqual(formatted, "2023-01-01T00:00:00+00:00")

    def test_get_post_data_with_comments(self):
        """Test that get_post_data returns correct data structure with comments"""
        post_data = get_post_data()

        # Should be ordered by date
        self.assertEqual(len(post_data), 2)
        self.assertEqual(post_data[0]["post_text"], "Test Post 1")
        self.assertEqual(post_data[1]["post_text"], "Test Post 2")

        # Check comments
        self.assertEqual(len(post_data[0]["comments"]), 2)
        self.assertEqual(len(post_data[1]["comments"]), 1)

        # Check structure of first post's first comment
        first_comment = post_data[0]["comments"][0]
        self.assertEqual(first_comment["comment_text"], "Test Comment 1")
        self.assertEqual(first_comment["ip"], "127.0.0.1")
        self.assertIsNone(
            first_comment["username"]
        )  # username is None since not implemented yet

    def test_get_all_data(self):
        """Test that get_all_data returns correct overall structure"""
        all_data = get_all_data()

        self.assertIn("posts", all_data)
        self.assertIn("users", all_data)
        self.assertEqual(len(all_data["posts"]), 2)
        self.assertEqual(
            len(all_data["users"]), 0
        )  # User data not implemented yet

    def test_export_endpoint(self):
        """Test the export endpoint returns a json file with correct content"""
        response = self.client.post(
            reverse("blog:management:export_file"), {"download": True}
        )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response["Content-Type"], "application/json")

        # Parse the JSON response

        # mypy can't figure out it's a FileResponse
        json_data = json.loads(b"".join(response.streaming_content))  # type: ignore

        # Verify structure
        self.assertIn("posts", json_data)
        self.assertIn("users", json_data)
        self.assertEqual(len(json_data["posts"]), 2)

    def test_export_with_no_posts(self):
        """Test export with empty database"""
        # Clear all posts
        Post.objects.all().delete()

        post_data = get_post_data()
        self.assertEqual(len(post_data), 0)

        all_data = get_all_data()
        self.assertEqual(len(all_data["posts"]), 0)

        # Test export endpoint with empty database
        response = self.client.post(
            reverse("blog:management:export_file"), {"download": True}
        )

        # mypy can't figure out it's a FileResponse
        json_data = json.loads(b"".join(response.streaming_content))  # type: ignore
        self.assertEqual(len(json_data["posts"]), 0)


class DataImportTests(TestCase):
    def setUp(self):
        # Create a staff user for testing
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )
        self.client.force_login(self.staff_user)

        # Sample export data for testing import
        self.sample_data = {
            "posts": [
                {
                    "post_text": "Imported Post 1",
                    "pub_date": "2023-02-01T10:00:00+00:00",
                    "comments": [
                        {
                            "comment_text": "Imported Comment 1",
                            "pub_date": "2023-02-01T10:30:00+00:00",
                            "username": None,
                            "ip": "192.168.1.1",
                        },
                        {
                            "comment_text": "Imported Comment 2",
                            "pub_date": "2023-02-01T11:00:00+00:00",
                            "username": None,
                            "ip": "192.168.1.2",
                        },
                    ],
                },
                {
                    "post_text": "Imported Post 2",
                    "pub_date": "2023-02-02T10:00:00+00:00",
                    "comments": [
                        {
                            "comment_text": "Imported Comment 3",
                            "pub_date": "2023-02-02T10:30:00+00:00",
                            "username": None,
                            "ip": "192.168.1.3",
                        }
                    ],
                },
            ],
            "users": [],
        }

    def create_test_file(self, data=None):
        """Helper method to create a test JSON file for import"""
        if data is None:
            data = self.sample_data

        json_data = json.dumps(data)
        return SimpleUploadedFile(
            "test_import.json",
            json_data.encode("utf-8"),
            content_type="application/json",
        )

    def test_convert_comment(self):
        """Test convert_comment correctly parses JSON comment data"""
        json_comment: ExportDataComment = {
            "comment_text": "Test Comment",
            "pub_date": "2023-01-01T12:00:00+00:00",
            "username": None,
            "ip": "127.0.0.1",
        }

        comment = convert_comment(json_comment)

        self.assertEqual(comment.comment_text, "Test Comment")
        self.assertEqual(
            comment.pub_date,
            datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC),
        )
        self.assertEqual(comment.ip, "127.0.0.1")

    def test_convert_post(self):
        """Test convert_post correctly parses JSON post data"""
        json_post: ExportPostData = {
            "post_text": "Test Post",
            "pub_date": "2023-01-01T12:00:00+00:00",
            "comments": [
                {
                    "comment_text": "Test Comment",
                    "pub_date": "2023-01-01T12:30:00+00:00",
                    "username": None,
                    "ip": "127.0.0.1",
                }
            ],
        }

        post = convert_post(json_post)

        self.assertEqual(post.post_text, "Test Post")
        self.assertEqual(
            post.pub_date, datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC)
        )
        self.assertEqual(len(post.comments), 1)
        self.assertEqual(post.comments[0].comment_text, "Test Comment")

    def test_import_with_empty_database(self):
        """Test importing posts into an empty database"""
        # Verify database is empty
        self.assertEqual(Post.objects.count(), 0)
        self.assertEqual(Comment.objects.count(), 0)

        # Create and upload import file
        import_file = self.create_test_file()
        response = self.client.post(
            reverse("blog:management:import"), {"data_file": import_file}
        )

        # Verify successful import
        self.assertEqual(response.status_code, 200)

        # Verify database now has the imported data
        self.assertEqual(Post.objects.count(), 2)
        self.assertEqual(Comment.objects.count(), 3)

        # Check specific post content
        posts = Post.objects.all().order_by("pub_date")
        self.assertEqual(posts[0].post_text, "Imported Post 1")
        self.assertEqual(posts[1].post_text, "Imported Post 2")

        # Check comment counts per post
        self.assertEqual(posts[0].comment_set.count(), 2)
        self.assertEqual(posts[1].comment_set.count(), 1)

    def test_import_preserves_existing_posts(self):
        """Test importing doesn't duplicate existing posts"""
        # Create a post with the same text as in sample data
        existing_post = Post.objects.create(
            post_text="Imported Post 1",
            pub_date=datetime(2022, 1, 1, tzinfo=UTC),  # Different date
        )
        existing_post.comment_set.create(
            comment_text="Existing Comment",
            pub_date=datetime(2022, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )

        # Initial counts
        self.assertEqual(Post.objects.count(), 1)
        self.assertEqual(Comment.objects.count(), 1)

        # Create and upload import file
        import_file = self.create_test_file()
        response = self.client.post(
            reverse("blog:management:import"), {"data_file": import_file}
        )

        # Verify successful import
        self.assertEqual(response.status_code, 200)

        # Verify database now has the correct data
        self.assertEqual(Post.objects.count(), 2)  # Original + 1 new
        self.assertEqual(
            Comment.objects.count(), 2
        )  # Original + 1 new from 2nd post

        # Check that existing post comments weren't modified
        existing_post.refresh_from_db()
        self.assertEqual(existing_post.comment_set.count(), 1)
        existing_comment = existing_post.comment_set.first()
        assert existing_comment is not None
        self.assertEqual(existing_comment.comment_text, "Existing Comment")

    def test_import_preview_endpoint(self):
        """Test the import preview endpoint"""
        # Prepare import request with file
        import_file = self.create_test_file()

        # Post to import preview endpoint
        response = self.client.post(
            reverse("blog:management:import_preview"),
            {"data_file": import_file},
        )

        # Verify response
        self.assertEqual(response.status_code, 200)

        # Database should remain unchanged after preview
        self.assertEqual(Post.objects.count(), 0)
        self.assertEqual(Comment.objects.count(), 0)

    def test_import_invalid_file_format(self):
        """Test importing with an invalid file format"""
        # Create a non-JSON file
        invalid_file = SimpleUploadedFile(
            "test.txt", b"This is not JSON", content_type="text/plain"
        )

        # Try to import invalid file
        response = self.client.post(
            reverse("blog:management:import"), {"data_file": invalid_file}
        )

        # Because we're using HTMX we want to return 200 pretty much always
        self.assertEqual(response.status_code, 200)

        # Database should remain empty
        self.assertEqual(Post.objects.count(), 0)

    def test_import_preserves_data_integrity(self):
        """Test that import maintains referential integrity"""
        # Create and upload import file
        import_file = self.create_test_file()
        self.client.post(
            reverse("blog:management:import"), {"data_file": import_file}
        )

        # Verify all comments have valid post references
        for comment in Comment.objects.all():
            self.assertIsNotNone(comment.post)
            self.assertTrue(Post.objects.filter(id=comment.post.id).exists())

        # Verify data matches expected values
        post = Post.objects.get(post_text="Imported Post 1")
        comments = post.comment_set.all().order_by("pub_date")
        self.assertEqual(comments[0].comment_text, "Imported Comment 1")
        self.assertEqual(comments[1].comment_text, "Imported Comment 2")

    def test_import_transaction_atomicity(self):
        """Test that imports are atomic - either all succeeds or nothing changes"""
        # Create a post that will already exist in the database
        existing_post = Post.objects.create(
            post_text="Existing Post", pub_date=datetime(2023, 1, 1, tzinfo=UTC)
        )
        existing_post.comment_set.create(
            comment_text="Existing Comment",
            pub_date=datetime(2023, 1, 1, 1, tzinfo=UTC),
            commenter_ip="127.0.0.1",
        )

        # Initial database state
        initial_post_count = Post.objects.count()
        initial_comment_count = Comment.objects.count()

        # Create import data with:
        # 1. Some valid posts at the beginning
        # 2. An invalid post that will cause an exception during processing
        malformed_data = {
            "posts": [
                # Valid post 1
                {
                    "post_text": "Valid Post 1",
                    "pub_date": "2023-02-01T10:00:00+00:00",
                    "comments": [
                        {
                            "comment_text": "Valid Comment 1",
                            "pub_date": "2023-02-01T10:30:00+00:00",
                            "username": None,
                            "ip": "192.168.1.1",
                        }
                    ],
                },
                # Valid post 2
                {
                    "post_text": "Valid Post 2",
                    "pub_date": "2023-02-02T10:00:00+00:00",
                    "comments": [
                        {
                            "comment_text": "Valid Comment 2",
                            "pub_date": "2023-02-02T10:30:00+00:00",
                            "username": None,
                            "ip": "192.168.1.2",
                        }
                    ],
                },
                # Invalid post - missing required pub_date field
                {
                    "post_text": "Invalid Post - Missing pub_date",
                    "comments": [],  # No comments to keep it simple
                },
            ],
            "users": [],
        }

        # Create the test file with malformed data
        import_file = self.create_test_file(malformed_data)

        # Try to import the malformed data
        self.client.post(
            reverse("blog:management:import"), {"data_file": import_file}
        )

        # Verify database state is unchanged
        self.assertEqual(
            Post.objects.count(),
            initial_post_count,
            "Post count should be unchanged after failed import",
        )
        self.assertEqual(
            Comment.objects.count(),
            initial_comment_count,
            "Comment count should be unchanged after failed import",
        )

        # Verify that none of the valid posts were imported either
        self.assertFalse(
            Post.objects.filter(post_text="Valid Post 1").exists(),
            "Valid Post 1 should not exist after a failed transaction",
        )
        self.assertFalse(
            Post.objects.filter(post_text="Valid Post 2").exists(),
            "Valid Post 2 should not exist after a failed transaction",
        )
