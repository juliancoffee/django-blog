from itertools import chain
from typing import TYPE_CHECKING

from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.test import TestCase
from django.urls import reverse

if TYPE_CHECKING:
    from django.forms import Form


class FormTestCase(TestCase):
    # I know that assertFormError exists, but it requires a fieldname, and that's
    # a weird limitation imo, so here's my version instead.
    def assertFormContainsErrorCode(self, response, error_code: str):
        """Check that form errors contain the error with error_code"""
        form: Form = response.context["form"]
        errors = form.errors.get_json_data()

        # flatmap and find the code for each message for each field
        # NOTE: eagerly evaluate the iterable for better error messages, but
        # it'd work without it as well
        error_codes = list(
            map(lambda e: e["code"], chain.from_iterable(errors.values()))
        )

        self.assertIn(error_code, error_codes)

    def check_current_user(self) -> User:
        """Get currently authenticated user"""
        # There should be some better way, but it seem to work just fine

        index_url = reverse("blog:index")
        r = self.client.get(index_url)
        return r.context["user"]


class AuthLoginTest(FormTestCase):
    def test_login_ok_simple(self):
        # create a user to work with
        NAME = "test_user"
        PASS = "password_super_cool"
        User.objects.create_user(username=NAME, password=PASS)

        # sanity check, we can't have a user yet
        self.assertFalse(self.check_current_user().is_authenticated)

        # now attempt the login
        login_url = reverse("blog:accounts:login")
        r = self.client.post(
            login_url,
            {
                "username": NAME,
                "password": PASS,
            },
        )

        # assert the redirect to the main page
        # TODO: create a test that checks redirects from `?next=` attribute?
        self.assertRedirects(r, reverse("blog:index"))

        # now we should be authenticated
        self.assertTrue(self.check_current_user().is_authenticated)

    def test_login_bad(self):
        # create a user to work with
        NAME = "test_user"
        PASS = "password_super_cool"
        User.objects.create_user(username=NAME, password=PASS)

        # sanity check, we can't have a user yet
        self.assertFalse(self.check_current_user().is_authenticated)

        # now attempt the login
        login_url = reverse("blog:accounts:login")
        r = self.client.post(
            login_url,
            {
                "username": NAME,
                "password": PASS + PASS,
            },
        )

        self.assertFormContainsErrorCode(r, "invalid_login")

        # and we shouldn't be authenticated
        self.assertFalse(self.check_current_user().is_authenticated)


class AuthRegistrationTest(FormTestCase):
    def test_registration_ok(self):
        register_url = reverse("blog:accounts:signup")

        NAME = "test_user"
        PASS = "password_super_cool"
        post_data = {
            "username": NAME,
            "password1": PASS,
            "password2": PASS,
        }
        r = self.client.post(register_url, post_data, follow=True)

        # assert successful redirect to index
        self.assertRedirects(r, reverse("blog:index"))

        # assert that users were created
        user_count = User.objects.filter(username=NAME).count()
        self.assertEqual(user_count, 1)

        # assert that we're logged in now
        self.assertTrue(self.check_current_user().is_authenticated)

        # check that we can authenticate with the same password
        authenticated_user = authenticate(username=NAME, password=PASS)
        self.assertIsNotNone(authenticated_user)

    def test_registration_err_common(self):
        # attempt a registration
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password",
            "password2": "password",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_too_common")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])

    def test_registration_err_password_too_short(self):
        # NOTE: generated by ChatGPT

        # attempt a registration with a short password
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "short",
            "password2": "short",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_too_short")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])

    def test_registration_err_username_not_unique(self):
        # NOTE: generated by ChatGPT

        # create an existing user
        User.objects.create_user(username="test_user", password="password")

        # attempt a registration with a duplicate username
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password123",
            "password2": "password123",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "unique")

        # assert that no additional users were created
        users = User.objects.all()
        self.assertEqual(users.count(), 1)

    def test_registration_err_password_mismatch(self):
        # NOTE: generated by ChatGPT

        # attempt a registration with mismatched passwords
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password123",
            "password2": "password321",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_mismatch")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])
