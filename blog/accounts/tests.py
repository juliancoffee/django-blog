from itertools import chain
from typing import TYPE_CHECKING

from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.test import TestCase
from django.urls import reverse

from .forms import UpdateEmailForm

if TYPE_CHECKING:
    from django.forms import Form


class FormTestCase(TestCase):
    # I know that assertFormError exists, but it requires a fieldname, and that's
    # a weird limitation imo, so here's my version instead.
    def assertFormContainsErrorCode(self, response, error_code: str):
        """Check that form errors contain the error with error_code"""
        form: Form = response.context["form"]
        errors = form.errors.get_json_data()

        # flatmap and find the code for each message for each field
        # NOTE: eagerly evaluate the iterable for better error messages, but
        # it'd work without it as well
        error_codes = list(
            map(lambda e: e["code"], chain.from_iterable(errors.values()))
        )

        self.assertIn(error_code, error_codes)

    def check_current_user(self) -> User:
        """Get currently authenticated user"""
        # There should be some better way, but it seem to work just fine

        index_url = reverse("blog:index")
        r = self.client.get(index_url)
        return r.context["user"]


class AuthLoginTest(FormTestCase):
    def test_login_ok_simple(self):
        # create a user to work with
        NAME = "test_user"
        PASS = "password_super_cool"
        User.objects.create_user(username=NAME, password=PASS)

        # sanity check, we can't have a user yet
        self.assertFalse(self.check_current_user().is_authenticated)

        # now attempt the login
        login_url = reverse("blog:accounts:login")
        r = self.client.post(
            login_url,
            {
                "username": NAME,
                "password": PASS,
            },
        )

        # assert the redirect to the main page
        # TODO: create a test that checks redirects from `?next=` attribute?
        self.assertRedirects(r, reverse("blog:index"))

        # now we should be authenticated
        self.assertTrue(self.check_current_user().is_authenticated)

    def test_login_bad(self):
        # create a user to work with
        NAME = "test_user"
        PASS = "password_super_cool"
        User.objects.create_user(username=NAME, password=PASS)

        # sanity check, we can't have a user yet
        self.assertFalse(self.check_current_user().is_authenticated)

        # now attempt the login
        login_url = reverse("blog:accounts:login")
        r = self.client.post(
            login_url,
            {
                "username": NAME,
                "password": PASS + PASS,
            },
        )

        self.assertFormContainsErrorCode(r, "invalid_login")

        # and we shouldn't be authenticated
        self.assertFalse(self.check_current_user().is_authenticated)


class AuthRegistrationTest(FormTestCase):
    def test_registration_ok(self):
        register_url = reverse("blog:accounts:signup")

        NAME = "test_user"
        PASS = "password_super_cool"
        post_data = {
            "username": NAME,
            "password1": PASS,
            "password2": PASS,
        }
        r = self.client.post(register_url, post_data, follow=True)

        # assert successful redirect to index
        self.assertRedirects(r, reverse("blog:index"))

        # assert that users were created
        user_count = User.objects.filter(username=NAME).count()
        self.assertEqual(user_count, 1)

        # assert that we're logged in now
        self.assertTrue(self.check_current_user().is_authenticated)

        # check that we can authenticate with the same password
        authenticated_user = authenticate(username=NAME, password=PASS)
        self.assertIsNotNone(authenticated_user)

    def test_registration_err_common(self):
        # attempt a registration
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password",
            "password2": "password",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_too_common")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])

    def test_registration_err_password_too_short(self):
        # NOTE: generated by ChatGPT

        # attempt a registration with a short password
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "short",
            "password2": "short",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_too_short")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])

    def test_registration_err_username_not_unique(self):
        # NOTE: generated by ChatGPT

        # create an existing user
        User.objects.create_user(username="test_user", password="password")

        # attempt a registration with a duplicate username
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password123",
            "password2": "password123",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "unique")

        # assert that no additional users were created
        users = User.objects.all()
        self.assertEqual(users.count(), 1)

    def test_registration_err_password_mismatch(self):
        # NOTE: generated by ChatGPT

        # attempt a registration with mismatched passwords
        register_url = reverse("blog:accounts:signup")
        post_data = {
            "username": "test_user",
            "password1": "password123",
            "password2": "password321",
        }
        r = self.client.post(register_url, post_data)

        # assert form's error code
        self.assertFormContainsErrorCode(r, "password_mismatch")

        # assert that no users were created
        users = User.objects.all()
        self.assertQuerySetEqual(users, [])


#
# THIS WHOLE CLASS WAS GENERATED BY CodeRabbitAI
#
class EmailFormTests(FormTestCase):
    def setUp(self):
        # Create a test user
        self.username = "test_user"
        self.password = "secure_password123"
        self.user = User.objects.create_user(
            username=self.username, password=self.password
        )
        # Log in the user
        self.client.login(username=self.username, password=self.password)

    def test_profile_view_contains_email_form(self):
        """Profile view should include the email form in the context"""
        url = reverse("blog:accounts:profile")
        response = self.client.get(url)

        self.assertEqual(response.status_code, 200)
        self.assertIn("email_form", response.context)
        self.assertIsInstance(response.context["email_form"], UpdateEmailForm)

    def test_email_form_fragment_renders_with_form_variable(self):
        """The email_form_fragment should render correctly with form variable"""
        url = reverse("blog:accounts:profile")
        response = self.client.get(url)

        self.assertEqual(response.status_code, 200)
        # The template should render without errors
        self.assertContains(response, '<div id="email-form">')
        self.assertContains(response, "<form")
        self.assertContains(response, "hx-post")

    def test_update_email_valid_submission(self):
        """Valid email submission should update user email"""
        url = reverse("blog:accounts:update_email")
        test_email = "test@example.com"
        response = self.client.post(url, {"email": test_email})

        # Should redirect to profile page
        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            response.headers.get("HX-Redirect"),
            reverse("blog:accounts:profile"),
        )

        # User email should be updated
        self.user.refresh_from_db()
        self.assertEqual(self.user.email, test_email)

    def test_update_email_invalid_submission(self):
        """Invalid email submission should return form with errors"""
        url = reverse("blog:accounts:update_email")
        invalid_email = "not-an-email"
        response = self.client.post(url, {"email": invalid_email})

        # Should return the form fragment with errors
        self.assertEqual(response.status_code, 200)
        self.assertIn("form", response.context)
        self.assertFormContainsErrorCode(response, "invalid")

        # User email should not be updated
        self.user.refresh_from_db()
        self.assertNotEqual(self.user.email, invalid_email)

    def test_include_with_syntax_passes_form_correctly(self):
        """Test that the 'include with' syntax correctly passes the form"""
        url = reverse("blog:accounts:profile")
        response = self.client.get(url)

        # The email_form from profile view should be passed correctly to the template
        self.assertEqual(response.status_code, 200)

        # Verify form renders in the template
        form_html = response.content.decode()
        self.assertIn('<input type="email" name="email"', form_html)
        self.assertIn(
            '<input type="submit" value="Update your email">', form_html
        )


# Yeah, this was generated by code rabbit, as well
#
# TODO:
# On another note, smth like that should be trivial to test fully.
# One test to rule them all, you know.
#
# We shouldn't test each individual page by hand and check whether it's possible
# to load.
#
# I think.
# On top of my head, the biggest issue would be to understand whether a view
# responds to GET, but then maybe it wouldn't be such an issue if all of them
# would properly respond with MethodNotAllowed.
class ProfileTemplateTests(TestCase):
    def setUp(self):
        # Create a staff user (since staff URL references are what we're testing)
        self.staff_user = User.objects.create_user(
            username="staffuser", password="testpassword", is_staff=True
        )

        # Create a regular user for comparison
        self.regular_user = User.objects.create_user(
            username="regularuser", password="testpassword", is_staff=False
        )

    def test_profile_page_loads_for_staff_user(self):
        """Test that profile page loads without errors for staff users"""
        self.client.force_login(self.staff_user)
        response = self.client.get(reverse("blog:accounts:profile"))

        # Check the page loads successfully
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, "blog/profile.html")

    def test_profile_page_loads_for_regular_user(self):
        """Test that profile page loads without errors for regular non-staff users"""
        self.client.force_login(self.regular_user)
        response = self.client.get(reverse("blog:accounts:profile"))

        # Check the page loads successfully
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, "blog/profile.html")
