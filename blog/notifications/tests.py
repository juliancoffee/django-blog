#
# THIS WHOLE FILE WAS GENERATED BY CodeRabbitAI
#
# well, almost
#
import logging
from typing import override

from django.contrib.auth.models import User
from django.core import mail
from django.test import Client, TestCase, override_settings
from django.urls import reverse
from django.utils import timezone

from blog.models import Comment, Post

from .forms import SubscribeForm
from .models import Subscription

logging.disable()


class SubscriptionModelTests(TestCase):
    @override
    def setUp(self):
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="testpassword",
        )

    def test_subscription_creation(self):
        """Test that a Subscription instance can be created"""
        subscription = Subscription.objects.create(
            user=self.user, to_new_posts=True, to_engaged_posts=False
        )
        self.assertEqual(subscription.user, self.user)
        self.assertTrue(subscription.to_new_posts)
        self.assertFalse(subscription.to_engaged_posts)

    def test_subscription_string_representation(self):
        """Test that the string representation is correct"""
        subscription = Subscription.objects.create(
            user=self.user, to_new_posts=True, to_engaged_posts=False
        )
        expected_str = "For testuser"
        self.assertEqual(str(subscription), expected_str)

    def test_subscription_default_values(self):
        """Test that default values are set correctly"""
        subscription = Subscription.objects.create(user=self.user)
        self.assertFalse(subscription.to_new_posts)
        self.assertFalse(subscription.to_engaged_posts)


class SubscribeFormTests(TestCase):
    def test_form_valid_data(self):
        """Test that the form validates with correct data"""
        form_data = {"to_new_posts": True, "to_engaged_posts": True}
        form = SubscribeForm(data=form_data)
        self.assertTrue(form.is_valid())

    def test_form_empty_data(self):
        """Test that the form is valid even without data (as fields are not required)"""
        form = SubscribeForm(data={})
        self.assertTrue(form.is_valid())

    def test_form_field_labels(self):
        """Test that the form fields have the correct labels"""
        form = SubscribeForm()
        self.assertEqual(
            form.fields["to_new_posts"].label, "Subscribe to new posts"
        )
        self.assertEqual(
            form.fields["to_engaged_posts"].label,
            "Subscribe to updates on engaged posts",
        )


class NotificationViewsTests(TestCase):
    @override
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="testpassword",
        )
        self.settings_url = reverse("blog:notifications:settings")

    def test_settings_view_get_authenticated(self):
        """Test that authenticated users can access the settings page"""
        self.client.login(username="testuser", password="testpassword")
        response = self.client.get(self.settings_url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, "blog/notif_settings.html")
        self.assertIsInstance(response.context["form"], SubscribeForm)

    def test_settings_view_post_valid_data(self):
        """Test that users can update their subscription preferences"""
        self.client.login(username="testuser", password="testpassword")

        # Initially there should be no subscription
        self.assertEqual(Subscription.objects.count(), 0)

        # Submit the form
        response = self.client.post(
            self.settings_url, {"to_new_posts": True, "to_engaged_posts": False}
        )

        # Should redirect to settings page after successful update
        self.assertEqual(response.status_code, 302)
        self.assertRedirects(response, self.settings_url)

        # Check that subscription was created with correct values
        self.assertEqual(Subscription.objects.count(), 1)
        subscription = Subscription.objects.get(user=self.user)
        self.assertTrue(subscription.to_new_posts)
        self.assertFalse(subscription.to_engaged_posts)

    def test_settings_view_post_update_existing(self):
        """Test that an existing subscription can be updated"""
        self.client.login(username="testuser", password="testpassword")

        # Create an initial subscription
        subscription = Subscription.objects.create(
            user=self.user, to_new_posts=False, to_engaged_posts=False
        )

        # Update via form submission
        self.client.post(
            self.settings_url, {"to_new_posts": True, "to_engaged_posts": True}
        )

        # Check that values were updated
        subscription.refresh_from_db()
        self.assertTrue(subscription.to_new_posts)
        self.assertTrue(subscription.to_engaged_posts)

    def test_get_or_create_subscription(self):
        """Test that get_or_create works properly for retrieving or creating subscriptions"""
        self.client.login(username="testuser", password="testpassword")

        # We shouldn't have any subscriptions at the beginning
        self.assertEqual(Subscription.objects.count(), 0)

        # First access should create a new subscription
        _ = self.client.get(self.settings_url)
        self.assertEqual(Subscription.objects.count(), 1)

        # Subsequent access should use the same subscription
        _ = self.client.get(self.settings_url)
        self.assertEqual(Subscription.objects.count(), 1)

    def test_subscription_cascade_deletion(self):
        """Test that subscriptions are deleted when the associated user is deleted"""
        # Create a user and subscription
        user = User.objects.create_user(
            username="tempuser", password="temppass"
        )
        subscription = Subscription.objects.create(
            user=user, to_new_posts=True, to_engaged_posts=True
        )

        # Verify subscription exists
        self.assertEqual(Subscription.objects.filter(user=user).count(), 1)

        # Delete the user
        user.delete()

        # Verify the subscription was also deleted
        self.assertEqual(
            Subscription.objects.filter(id=subscription.id).count(), 0
        )


class IntegrationTests(TestCase):
    @override
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="testpassword",
        )

    def test_end_to_end_subscription_workflow(self):
        """
        Test the complete flow:
        1. User logs in
        2. Navigates to settings
        3. Updates preferences
        4. Verifies changes when revisiting the page
        """
        # p. s.
        # Testing forms in Django is kind of annoying.
        # - If you have ModelForm, you need to use `form.instance.<field>`
        # - If it's a regular Form, you need to use `form.data["<field>"]`
        #
        # I like Django forms less and less.
        #
        # p. p. s. coderabbitai made my change my comments, because previous
        # ones were "considered unprofessional"

        self.client.login(username="testuser", password="testpassword")
        settings_url = reverse("blog:notifications:settings")

        # First visit - should show default values (unchecked)
        response = self.client.get(settings_url)
        self.assertEqual(response.status_code, 200)
        form = response.context["form"]
        self.assertFalse(form.instance.to_new_posts)
        self.assertFalse(form.instance.to_engaged_posts)

        # Update preferences
        response = self.client.post(
            settings_url, {"to_new_posts": True, "to_engaged_posts": True}
        )
        self.assertEqual(response.status_code, 302)

        # Visit again - form should now show checked values
        response = self.client.get(settings_url)
        form = response.context["form"]
        self.assertTrue(form.instance.to_new_posts)
        self.assertTrue(form.instance.to_engaged_posts)


def new_subscribed_to(
    username: str,
    *,
    email: str | None = None,
    password: str = "password123",
    to_new_posts: bool = False,
    to_engaged_posts: bool = False,
):
    user = User.objects.create_user(
        username=username,
        email=email,
        password=password,
    )
    Subscription.objects.create(
        user=user,
        to_new_posts=to_new_posts,
        to_engaged_posts=to_engaged_posts,
    )

    return user


@override_settings(
    DEFAULT_FROM_EMAIL="test@example.com",
)
class NotificationEmailTests(TestCase):
    """Test email notifications sent when posts are created or updated."""

    def assertEmailsEqual(self, emails_to: list[str]):
        # Get the recipient emails from the sent messages
        recipient_emails = sorted(msg.to for msg in mail.outbox)
        expected = sorted([email] for email in emails_to)

        # Verify that both new post subscribers received emails
        # And it doesn't list other subscribers
        self.assertSequenceEqual(
            recipient_emails,
            expected,
        )

    @override
    def setUp(self):
        """Set up test data."""

        # Add non subscribed user as control/canary
        self.nonsub = new_subscribed_to("nonsub", email="nonsub@example.com")

        # Add starter post to comment on
        self.starter_post = Post.objects.create(
            post_text="Starter post",
            pub_date=timezone.now(),
        )

        # Clear the email outbox before each test
        mail.outbox = []

    def test_new_post_notification(self):
        """Test that new post notifications are sent"""
        # Create subscribers
        new_post_subscriber = new_subscribed_to(
            "new_sub", email="newsub1@example.com", to_new_posts=True
        )
        all_post_subscriber = new_subscribed_to(
            "new_sub2",
            email="newsub2@example.com",
            to_engaged_posts=True,
            to_new_posts=True,
        )

        # Create a new post
        post = Post.objects.create(
            post_text="This is a new post that should trigger notifications",
            pub_date=timezone.now(),
        )

        # Check that emails were sent, one for each subscriber
        self.assertEqual(len(mail.outbox), 2)
        self.assertEmailsEqual(
            [
                new_post_subscriber.email,
                all_post_subscriber.email,
            ]
        )

        # Check email content
        # Check that post text is in the email
        for msg in mail.outbox:
            self.assertEqual(msg.subject, "Such Subject")
            self.assertIn(post.post_text[:30], msg.body)

    def test_non_email_email(self):
        """Test that emails to non-email users aren't sent"""
        _mistaken_subscriber = new_subscribed_to(
            username="engaged_sub",
            email=None,
            to_new_posts=True,
        )

        _post = Post.objects.create(
            post_text="This is a new post that should trigger notifications",
            pub_date=timezone.now(),
        )

        # Check that no emails were sent
        self.assertSequenceEqual(mail.outbox, [])

    def test_update_emails(self):
        enaged_sub = new_subscribed_to(
            "new_sub2",
            email="newsub2@example.com",
            to_engaged_posts=True,
        )

        # Update the post
        Comment.objects.create(
            post_id=self.starter_post.id,
            comment_text="hi there",
            pub_date=timezone.now(),
        )

        # Check that emails were sent, exactly one
        self.assertEqual(len(mail.outbox), 1)
        self.assertEmailsEqual([enaged_sub.email])

    def test_no_duplicated_emails(self):
        """Test that emails don't duplicate"""
        # Create subscribers
        new_post_subscriber = new_subscribed_to(
            "new_sub", email="newsub1@example.com", to_new_posts=True
        )
        all_post_subscriber = new_subscribed_to(
            "new_sub2",
            email="newsub2@example.com",
            to_engaged_posts=True,
            to_new_posts=True,
        )

        # Update the post
        Comment.objects.create(
            post_id=self.starter_post.id,
            comment_text="hi there",
            pub_date=timezone.now(),
        )

        # Check that emails were sent, one for each subscriber
        self.assertEqual(len(mail.outbox), 2)
        self.assertEmailsEqual(
            [
                new_post_subscriber.email,
                all_post_subscriber.email,
            ]
        )
